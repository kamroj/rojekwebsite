---
import PageHeaderSsg from '../PageHeaderSsg.astro';
import BreadcrumbsSsg from '../BreadcrumbsSsg.astro';
import PaginationSsg from '../PaginationSsg.astro';

import maxWidthStyles from '../../../ui/MaxWidthContainer.module.css';
import styles from '../../../../views/RealizationsView.module.css';

import { loadTranslationJson } from '../../../../lib/i18n/resources.js';
import { t as tt, tPlural } from '../../../../lib/i18n/t.js';
import { getSectionPath } from '../../../../lib/i18n/routing.js';
import { fetchRealizationsPageData } from '../../../../lib/sanity/realizations.js';
import { getSanityImageProps } from '../../../../lib/sanity/sanityImageProps.js';

const {
  lang = 'pl',
  realizations: realizationsProp,
  pagination,
} = Astro.props;

const tr = await loadTranslationJson(lang);
const t = (key, def = '') => tt(tr, key, def);

const breadcrumbs = [
  { label: t('breadcrumbs.home', 'Home'), to: getSectionPath(lang, 'home') },
  { label: t('breadcrumbs.realizations', 'Realizations') },
];

const realizations = Array.isArray(realizationsProp)
  ? realizationsProp
  : await fetchRealizationsPageData({ lang });

const resultsTemplate =
  tPlural(tr, 'realizationsPage.results.found', realizations.length, lang, 'Znaleziono {{count}} realizacji') ||
  'Znaleziono {{count}} realizacji';
const initialResultsHtml = resultsTemplate.replace('{{count}}', `<span class="${styles.filterCounterNumber}">${realizations.length}</span>`);
const counterTemplateOne = tt(tr, 'realizationsPage.results.found_one', resultsTemplate) || resultsTemplate;
const counterTemplateFew = tt(tr, 'realizationsPage.results.found_few', resultsTemplate) || resultsTemplate;
const counterTemplateMany = tt(tr, 'realizationsPage.results.found_many', resultsTemplate) || resultsTemplate;
const counterTemplateOther = tt(tr, 'realizationsPage.results.found_other', resultsTemplate) || resultsTemplate;

const filterGroupsMap = /** @type {Map<string, { key: string, label: string, options: Map<string, { key: string, label: string }> }>} */ (new Map());
for (const realization of realizations) {
  for (const tag of realization.tags || []) {
    if (!filterGroupsMap.has(tag.categoryKey)) {
      filterGroupsMap.set(tag.categoryKey, {
        key: tag.categoryKey,
        label: tag.categoryLabel,
        options: new Map(),
      });
    }
    const group = filterGroupsMap.get(tag.categoryKey);
    if (!group.options.has(tag.valueKey)) {
      group.options.set(tag.valueKey, {
        key: tag.valueKey,
        label: tag.valueLabel,
      });
    }
  }
}

/**
 * @param {{ key: string }} a
 * @param {{ key: string }} b
 */
const sortByKey = (a, b) =>
  String(a.key || '').localeCompare(String(b.key || ''), 'pl', { sensitivity: 'base' });

const baseFilterGroups = Array.from(filterGroupsMap.values()).map((group) => {
  const options = Array.from(group.options.values()).sort(sortByKey);

  return {
    ...group,
    options,
  };
}).sort(sortByKey);

const filterGroups = baseFilterGroups;
---

<div>
  <PageHeaderSsg
    imageSrc="/images/realizations/top.jpg"
    title={t('realizationsPage.title', 'Realizacje')}
    height={500}
  />

  <div class={maxWidthStyles.root} data-max-width-container="true">
    <BreadcrumbsSsg items={breadcrumbs} />

    <div class={styles.realizationsLayout}>
      <aside
        id="realizations-filters-sidebar"
        class={styles.filtersSidebar}
        aria-label={t('realizationsPage.filters.filtersTitle', 'Filtry')}
        role="dialog"
        aria-modal="true"
        aria-hidden="true"
      >
        <header class={styles.filtersSidebarHeader}>
          <h2 class={styles.filtersSidebarTitle}>{t('realizationsPage.filters.filtersTitle', 'Filtry')}</h2>
          <button id="realizations-mobile-filters-close" type="button" class={styles.mobileDrawerClose} aria-label={t('realizationsPage.filters.close', 'Zamknij')}>✕</button>
        </header>

        <div class={styles.filterPanelTop}>
          <input
            id="realizations-filter-search"
            class={styles.filterSearchInput}
            type="search"
            placeholder={t('realizationsPage.filters.searchPlaceholder', 'Szukaj tagu, np. DR')}
            aria-label={t('realizationsPage.filters.searchPlaceholder', 'Szukaj tagu, np. DR')}
            autocomplete="off"
          />
          <button
            id="realizations-filter-reset-top"
            type="button"
            class={`${styles.filterResetButton} ${styles.desktopOnlyReset}`}
          >
            {t('realizationsPage.filters.clear', 'Wyczyść')}
          </button>
        </div>

        <div class={styles.filterGroups}>
          <ul class={styles.filterCategoryList}>
            {filterGroups.map((group) => (
              <li class={styles.filterCategoryItem} data-filter-group>
                <div class={styles.filterGroupHeader}>
                  <span class={styles.filterGroupTitle}>{group.label}</span>
                </div>

                <ul class={styles.filterOptionsList}>
                  {group.options.map((option) => (
                    <li
                      class={styles.filterOptionItem}
                      data-filter-option
                      data-filter-search-text={`${group.label} ${option.label}`.toUpperCase()}
                    >
                      <label class={styles.filterOption}>
                        <input
                          type="checkbox"
                          class={styles.filterOptionInput}
                          data-filter-input
                          data-filter-value={`${group.key}::${option.key}`}
                          data-category-label={group.label}
                          data-option-label={option.label}
                        />
                        <span class={styles.filterOptionText}>{option.label}</span>
                      </label>
                    </li>
                  ))}
                </ul>
              </li>
            ))}
          </ul>
        </div>

        <footer class={styles.mobileDrawerActions}>
          <button id="realizations-mobile-filters-apply" type="button" class={styles.mobileApplyButton}>
            {t('realizationsPage.filters.apply', 'Zastosuj')}
          </button>
          <button id="realizations-filter-reset-bottom" type="button" class={styles.mobileClearButton}>
            {t('realizationsPage.filters.clear', 'Wyczyść')}
          </button>
        </footer>
      </aside>

      <section class={styles.realizationsContent}>
        <div class={styles.contentTopBar}>
          <button id="realizations-mobile-filters-open" type="button" class={styles.mobileFiltersButton}>
            {t('realizationsPage.filters.filtersTitle', 'Filtry')}
          </button>
          <div
            class={styles.filterCounter}
            data-filter-counter
            data-counter-lang={lang}
            data-counter-number-class={styles.filterCounterNumber}
            data-counter-template={resultsTemplate}
            data-counter-template-one={counterTemplateOne}
            data-counter-template-few={counterTemplateFew}
            data-counter-template-many={counterTemplateMany}
            data-counter-template-other={counterTemplateOther}
          >
            <Fragment set:html={initialResultsHtml} />
          </div>
        </div>

        <div class={styles.realizationsContainer} id="realizations-grid">
          {realizations.map((item, idx) => (
            <div
              class={styles.singleRealizationContainer}
              data-tag-pairs={(item.tagPairs || []).join(',')}
              data-realization-card
              role="button"
              tabindex="0"
              aria-label={t('realizationsPage.filters.openImage', 'Powiększ realizację')}
            >
              {(() => {
                const imageProps = getSanityImageProps(item.image, {
                  widths: [420, 640, 960],
                  sizes: '(max-width: 768px) 100vw, (max-width: 1400px) 50vw, 33vw',
                  loading: 'lazy',
                  altFallback: `${t('realizationsPage.title', 'Realizacje')} ${idx + 1}`,
                });

                return imageProps ? (
                  <div class="media-spinner-host" data-media-spinner>
                    <span class="media-spinner-overlay" aria-hidden="true">
                      <span class="media-spinner-ring"></span>
                    </span>
                    <img
                      class={styles.realizationImage}
                      src={imageProps.src}
                      srcset={imageProps.srcset}
                      sizes={imageProps.sizes}
                      width={imageProps.width}
                      height={imageProps.height}
                      alt={item.alt || imageProps.alt}
                      loading={imageProps.loading}
                      decoding={imageProps.decoding}
                      fetchpriority={imageProps.fetchpriority}
                      style={item?.image?.asset?.metadata?.lqip
                        ? `background-image:url(${item.image.asset.metadata.lqip});background-size:cover;background-position:center;`
                        : undefined}
                    />
                  </div>
                ) : null;
              })()}
            </div>
          ))}
        </div>

        <PaginationSsg
          pagination={pagination}
          ariaLabel={t('pagination.navigation', 'Pagination')}
        />
      </section>
    </div>

    <div id="realizations-filters-backdrop" class={styles.mobileDrawerBackdrop} aria-hidden="true"></div>

    <div id="realization-lightbox" class={styles.lightbox} aria-hidden="true">
      <div class={styles.lightboxBackdrop} data-lightbox-close></div>
      <div
        id="realization-lightbox-dialog"
        class={styles.lightboxDialog}
        role="dialog"
        aria-modal="true"
        aria-label={t('realizationsPage.filters.openImage', 'Podgląd realizacji')}
        tabindex="-1"
      >
        <button
          id="lightbox-close"
          type="button"
          class={styles.lightboxClose}
          aria-label={t('realizationsPage.filters.close', 'Zamknij')}
        >
          <svg class={styles.lightboxCloseIcon} viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M18.3 5.71a1 1 0 0 0-1.42 0L12 10.59 7.12 5.7a1 1 0 0 0-1.41 1.42L10.59 12l-4.9 4.88a1 1 0 1 0 1.42 1.42L12 13.41l4.88 4.9a1 1 0 0 0 1.42-1.42L13.41 12l4.9-4.88a1 1 0 0 0-.01-1.41Z" fill="currentColor" />
          </svg>
        </button>

        <button
          id="lightbox-prev"
          type="button"
          class={styles.lightboxNavPrev}
          aria-label={t('realizationsPage.filters.prev', 'Poprzednia')}
        >
          <svg class={styles.lightboxNavIcon} viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M15.41 7.41 10.83 12l4.58 4.59L14 18l-6-6 6-6z" fill="currentColor" />
          </svg>
        </button>

        <figure id="lightbox-image-frame" class={styles.lightboxFigure}>
          <img id="lightbox-image" class={styles.lightboxImage} alt="" />
          <figcaption id="lightbox-tags" class={styles.lightboxTags}></figcaption>
        </figure>

        <button
          id="lightbox-next"
          type="button"
          class={styles.lightboxNavNext}
          aria-label={t('realizationsPage.filters.next', 'Następna')}
        >
          <svg class={styles.lightboxNavIcon} viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="m8.59 16.59 4.58-4.59-4.58-4.59L10 6l6 6-6 6z" fill="currentColor" />
          </svg>
        </button>
      </div>
    </div>
  </div>
</div>

<style is:global>
  .media-spinner-host {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .media-spinner-overlay {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
    transition: opacity 0.22s ease;
    z-index: 2;
  }

  .media-spinner-ring {
    width: 34px;
    height: 34px;
    border-radius: 999px;
    border: 3px solid rgba(2, 99, 3, 0.2);
    border-top-color: #1a5618;
    animation: realizations-media-spinner-rotate 0.8s linear infinite;
  }

  .media-spinner-host[data-loaded='true'] .media-spinner-overlay {
    opacity: 0;
  }

  @keyframes realizations-media-spinner-rotate {
    to {
      transform: rotate(360deg);
    }
  }
</style>

<script is:inline data-astro-rerun>
  (() => {
    const mediaSpinnerHosts = Array.from(document.querySelectorAll('[data-media-spinner]'));

    mediaSpinnerHosts.forEach((host) => {
      const media = host.querySelector('img');
      if (!media) return;

      const markLoaded = () => host.setAttribute('data-loaded', 'true');

      if (media.complete) {
        markLoaded();
      } else {
        media.addEventListener('load', markLoaded, { once: true });
        media.addEventListener('error', markLoaded, { once: true });
      }
    });
  })();

  const filtersSidebar = document.getElementById('realizations-filters-sidebar');
  const filtersBackdrop = document.getElementById('realizations-filters-backdrop');
  const mobileFiltersOpen = document.getElementById('realizations-mobile-filters-open');
  const mobileFiltersClose = document.getElementById('realizations-mobile-filters-close');
  const mobileFiltersApply = document.getElementById('realizations-mobile-filters-apply');
  const filterSearchInput = document.getElementById('realizations-filter-search');
  const filterInputs = Array.from(document.querySelectorAll('[data-filter-input]'));
  const filterOptions = Array.from(document.querySelectorAll('[data-filter-option]'));
  const filterGroups = Array.from(document.querySelectorAll('[data-filter-group]'));
  const resetButtons = [
    document.getElementById('realizations-filter-reset-top'),
    document.getElementById('realizations-filter-reset-bottom'),
  ].filter(Boolean);
  const selectedFiltersBox = document.getElementById('realizations-selected-filters');
  const selectedChipsContainer = document.getElementById('realizations-selected-chips');
  const cards = Array.from(document.querySelectorAll('[data-realization-card]'));
  const counters = Array.from(document.querySelectorAll('[data-filter-counter]'));
  const counterNumberClass = counters[0]?.getAttribute('data-counter-number-class') || 'filterCounterNumber';
  const selectedByCategory = new Map();
  const optionMetaByPair = new Map();

  const lightbox = document.getElementById('realization-lightbox');
  const lightboxDialog = document.getElementById('realization-lightbox-dialog');
  const lightboxImage = document.getElementById('lightbox-image');
  const lightboxTags = document.getElementById('lightbox-tags');
  const lightboxClose = document.getElementById('lightbox-close');
  const lightboxPrev = document.getElementById('lightbox-prev');
  const lightboxNext = document.getElementById('lightbox-next');
  const lightboxBackdrop = document.querySelector('[data-lightbox-close]');
  const lightboxFrame = document.getElementById('lightbox-image-frame');

  let visibleCards = [];
  let activeCardIndex = -1;
  let touchStartX = 0;
  let mobileZoomRafId = 0;
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const LIGHTBOX_SWITCH_MS = prefersReducedMotion ? 0 : 180;
  const LIGHTBOX_ENTER_MS = prefersReducedMotion ? 0 : 220;
  let lightboxSwitchTimeoutId = 0;
  let lightboxEnterTimeoutId = 0;

  const isMobileViewport = () => window.matchMedia('(max-width: 767px)').matches;

  const setMobileDrawerOpen = (shouldOpen) => {
    if (!filtersSidebar) return;
    filtersSidebar.setAttribute('data-mobile-open', String(shouldOpen));
    filtersSidebar.setAttribute('aria-hidden', String(!shouldOpen));
    filtersBackdrop?.setAttribute('data-open', String(shouldOpen));
    filtersBackdrop?.setAttribute('aria-hidden', String(!shouldOpen));
    document.body.style.overflow = shouldOpen ? 'hidden' : '';
  };

  const closeMobileDrawer = () => setMobileDrawerOpen(false);

  const renderSelectedFilters = () => {
    if (!selectedFiltersBox || !selectedChipsContainer) return;

    const chips = [];

    for (const [category, selectedValues] of selectedByCategory.entries()) {
      for (const value of selectedValues) {
        const pair = `${category}::${value}`;
        const meta = optionMetaByPair.get(pair);
        chips.push({
          pair,
          label: meta ? `${meta.categoryLabel}: ${meta.optionLabel}` : `${category}: ${value}`,
        });
      }
    }

    selectedChipsContainer.innerHTML = '';
    selectedFiltersBox.hidden = chips.length === 0;

    chips.forEach((chip) => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'realizations-selected-chip';
      button.setAttribute('data-chip-pair', chip.pair);
      button.innerHTML = `<span>${chip.label}</span><span aria-hidden="true">✕</span>`;
      button.addEventListener('click', () => {
        toggleFilter(chip.pair, false);
        syncInputsFromSelection();
        applyFilters();
        renderSelectedFilters();
      });
      selectedChipsContainer.appendChild(button);
    });
  };

  const clearLightboxTransitionClasses = () => {
    if (!lightboxImage) return;
    lightboxImage.classList.remove(
      'is-switching-next',
      'is-switching-prev',
      'is-entering-next',
      'is-entering-prev',
      'is-enter-active'
    );
  };

  const setupScrollReveal = () => {
    cards.forEach((card, index) => {
      card.classList.add('reveal-on-scroll');
      card.style.transitionDelay = `${Math.min(index * 40, 220)}ms`;
    });

    if (prefersReducedMotion || !('IntersectionObserver' in window)) {
      cards.forEach((card) => card.classList.add('is-visible'));
      return;
    }

    const observer = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) return;
          entry.target.classList.add('is-visible');
          obs.unobserve(entry.target);
        });
      },
      { threshold: 0.15, rootMargin: '0px 0px -8% 0px' }
    );

    cards.forEach((card) => observer.observe(card));
  };

  const isLightboxOpen = () => lightbox?.getAttribute('aria-hidden') === 'false';
  const getVisibleCards = () => cards.filter((card) => !card.classList.contains('realization-hidden-by-filter'));

  const clearMobileActiveCard = () => {
    cards.forEach((card) => card.removeAttribute('data-mobile-active'));
  };

  const updateMobileActiveCard = () => {
    const visible = getVisibleCards();
    if (!visible.length) {
      clearMobileActiveCard();
      return;
    }

    const viewportCenterY = window.innerHeight / 2;
    let bestCard = null;
    let bestDistance = Number.POSITIVE_INFINITY;

    for (const card of visible) {
      const rect = card.getBoundingClientRect();
      const cardCenterY = rect.top + rect.height / 2;
      const distance = Math.abs(cardCenterY - viewportCenterY);

      if (distance < bestDistance) {
        bestDistance = distance;
        bestCard = card;
      }
    }

    cards.forEach((card) => {
      const shouldActivate = bestCard === card;
      if (shouldActivate) {
        card.setAttribute('data-mobile-active', 'true');
      } else {
        card.removeAttribute('data-mobile-active');
      }
    });
  };

  const scheduleMobileActiveUpdate = () => {
    if (mobileZoomRafId) return;
    mobileZoomRafId = window.requestAnimationFrame(() => {
      mobileZoomRafId = 0;
      updateMobileActiveCard();
    });
  };

  const fillLightboxFromCard = (card) => {
    const image = card.querySelector('img');
    const tags = card.querySelector('[class*="realizationTags"]');
    if (!image || !lightboxImage) return;

    lightboxImage.setAttribute('src', image.getAttribute('src') || '');

    const srcset = image.getAttribute('srcset');
    const sizes = image.getAttribute('sizes');
    if (srcset) lightboxImage.setAttribute('srcset', srcset);
    else lightboxImage.removeAttribute('srcset');
    if (sizes) lightboxImage.setAttribute('sizes', sizes);
    else lightboxImage.removeAttribute('sizes');

    lightboxImage.setAttribute('alt', image.getAttribute('alt') || '');
    if (lightboxTags) lightboxTags.innerHTML = tags ? tags.innerHTML : '';
  };

  const renderLightbox = ({ instant = false, direction = 1 } = {}) => {
    if (!visibleCards.length || activeCardIndex < 0) return;

    const nextCard = visibleCards[activeCardIndex];
    if (!nextCard || !lightboxImage) return;

    if (lightboxSwitchTimeoutId) {
      window.clearTimeout(lightboxSwitchTimeoutId);
      lightboxSwitchTimeoutId = 0;
    }
    if (lightboxEnterTimeoutId) {
      window.clearTimeout(lightboxEnterTimeoutId);
      lightboxEnterTimeoutId = 0;
    }

    if (instant || LIGHTBOX_SWITCH_MS === 0) {
      fillLightboxFromCard(nextCard);
      clearLightboxTransitionClasses();
      return;
    }

    const movingNext = direction >= 0;
    const exitClass = movingNext ? 'is-switching-next' : 'is-switching-prev';
    const enterClass = movingNext ? 'is-entering-next' : 'is-entering-prev';

    clearLightboxTransitionClasses();
    lightboxImage.classList.add(exitClass);

    lightboxSwitchTimeoutId = window.setTimeout(() => {
      fillLightboxFromCard(nextCard);

      lightboxImage.classList.remove(exitClass);
      lightboxImage.classList.add(enterClass);

      // Wymuszamy repaint, żeby klasa wejścia została na pewno zastosowana
      // przed jej zdjęciem (stabilniejszy kierunek fade-in na różnych przeglądarkach).
      void lightboxImage.offsetWidth;

      window.requestAnimationFrame(() => {
        lightboxImage.classList.add('is-enter-active');
      });

      lightboxEnterTimeoutId = window.setTimeout(() => {
        lightboxImage.classList.remove(enterClass, 'is-enter-active');
        lightboxEnterTimeoutId = 0;
      }, LIGHTBOX_ENTER_MS);

      lightboxSwitchTimeoutId = 0;
    }, LIGHTBOX_SWITCH_MS);
  };

  const moveLightbox = (step) => {
    if (!visibleCards.length) return;
    activeCardIndex = (activeCardIndex + step + visibleCards.length) % visibleCards.length;
    renderLightbox({ direction: step });
  };

  const closeLightbox = () => {
    if (!lightbox) return;
    if (lightboxSwitchTimeoutId) {
      window.clearTimeout(lightboxSwitchTimeoutId);
      lightboxSwitchTimeoutId = 0;
    }
    if (lightboxEnterTimeoutId) {
      window.clearTimeout(lightboxEnterTimeoutId);
      lightboxEnterTimeoutId = 0;
    }
    clearLightboxTransitionClasses();
    lightbox.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    activeCardIndex = -1;
    visibleCards = [];
  };

  const openLightbox = (card) => {
    visibleCards = getVisibleCards();
    if (!visibleCards.length) return;

    activeCardIndex = visibleCards.indexOf(card);
    if (activeCardIndex < 0) activeCardIndex = 0;

    renderLightbox({ instant: true });

    if (!lightbox || !lightboxDialog) return;
    lightbox.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    lightboxDialog.focus();
  };

  const toggleFilter = (pair, forceChecked) => {
    const [category, value] = String(pair || '').split('::');
    if (!category || !value) return;

    if (!selectedByCategory.has(category)) {
      selectedByCategory.set(category, new Set());
    }

    const values = selectedByCategory.get(category);
    if (forceChecked === false || (forceChecked == null && values.has(value))) {
      values.delete(value);
      if (!values.size) selectedByCategory.delete(category);
    } else if (forceChecked === true || forceChecked == null) {
      values.add(value);
    }
  };

  const syncInputsFromSelection = () => {
    filterInputs.forEach((input) => {
      const pair = input.getAttribute('data-filter-value') || '';
      const [category, value] = pair.split('::');
      input.checked = Boolean(selectedByCategory.get(category)?.has(value));
    });
  };

  const applyFilterSearch = () => {
    const query = String(filterSearchInput?.value || '').trim().toUpperCase();

    filterOptions.forEach((option) => {
      const haystack = option.getAttribute('data-filter-search-text') || '';
      const visible = !query || haystack.includes(query);
      option.style.display = visible ? '' : 'none';
    });

    filterGroups.forEach((group) => {
      const anyVisible = Array.from(group.querySelectorAll('[data-filter-option]')).some(
        (option) => option.style.display !== 'none'
      );
      group.style.display = anyVisible ? '' : 'none';
    });
  };

  const applyFilters = () => {
    let visibleCount = 0;

    for (const card of cards) {
      const rawPairs = (card.getAttribute('data-tag-pairs') || '').split(',').filter(Boolean);
      const itemMap = new Map();

      for (const pair of rawPairs) {
        const [category, value] = pair.split('::');
        if (!category || !value) continue;
        if (!itemMap.has(category)) itemMap.set(category, new Set());
        itemMap.get(category).add(value);
      }

      let matches = true;
      for (const [category, wantedValues] of selectedByCategory.entries()) {
        const itemValues = itemMap.get(category);
        const hasAny = itemValues && Array.from(wantedValues).some((value) => itemValues.has(value));
        if (!hasAny) {
          matches = false;
          break;
        }
      }

      card.classList.toggle('realization-hidden-by-filter', !matches);
      if (matches) visibleCount += 1;
    }

    counters.forEach((counterItem) => {
      const counterLang = counterItem.getAttribute('data-counter-lang') || 'en';
      let pluralCategory = 'other';
      try {
        pluralCategory = new Intl.PluralRules(counterLang).select(visibleCount);
      } catch {
        pluralCategory = 'other';
      }

      const template =
        counterItem.getAttribute(`data-counter-template-${pluralCategory}`) ||
        counterItem.getAttribute('data-counter-template-other') ||
        counterItem.getAttribute('data-counter-template') ||
        'Znaleziono {{count}} realizacji';
      counterItem.innerHTML = template.replace('{{count}}', `<span class="${counterNumberClass}">${visibleCount}</span>`);
    });

    if (isLightboxOpen()) {
      const nextVisibleCards = getVisibleCards();
      if (!nextVisibleCards.length) {
        closeLightbox();
      } else {
        const currentCard = visibleCards[activeCardIndex];
        visibleCards = nextVisibleCards;
        activeCardIndex = Math.max(0, visibleCards.indexOf(currentCard));
        renderLightbox();
      }
    }

    scheduleMobileActiveUpdate();
  };

  filterInputs.forEach((input) => {
    const pair = input.getAttribute('data-filter-value') || '';
    optionMetaByPair.set(pair, {
      categoryLabel: input.getAttribute('data-category-label') || '',
      optionLabel: input.getAttribute('data-option-label') || '',
    });

    input.addEventListener('change', () => {
      const pair = input.getAttribute('data-filter-value') || '';
      toggleFilter(pair, input.checked);
      applyFilters();
      renderSelectedFilters();
    });
  });

  filterSearchInput?.addEventListener('input', applyFilterSearch);

  resetButtons.forEach((button) => {
    button.addEventListener('click', () => {
      selectedByCategory.clear();
      syncInputsFromSelection();
      applyFilters();
      renderSelectedFilters();
    });
  });

  mobileFiltersOpen?.addEventListener('click', () => setMobileDrawerOpen(true));
  mobileFiltersClose?.addEventListener('click', closeMobileDrawer);
  mobileFiltersApply?.addEventListener('click', closeMobileDrawer);
  filtersBackdrop?.addEventListener('click', closeMobileDrawer);

  syncInputsFromSelection();
  applyFilterSearch();
  renderSelectedFilters();
  setupScrollReveal();
  scheduleMobileActiveUpdate();

  window.addEventListener('scroll', scheduleMobileActiveUpdate, { passive: true });
  document.addEventListener('scroll', scheduleMobileActiveUpdate, true);
  window.addEventListener('resize', scheduleMobileActiveUpdate);
  window.setTimeout(scheduleMobileActiveUpdate, 0);

  cards.forEach((card) => {
    card.addEventListener('click', () => openLightbox(card));
    card.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        openLightbox(card);
      }
    });
  });

  lightboxClose?.addEventListener('click', closeLightbox);
  lightboxBackdrop?.addEventListener('click', closeLightbox);
  lightboxPrev?.addEventListener('click', () => moveLightbox(-1));
  lightboxNext?.addEventListener('click', () => moveLightbox(1));

  lightboxFrame?.addEventListener('touchstart', (event) => {
    touchStartX = event.changedTouches?.[0]?.clientX || 0;
  }, { passive: true });

  lightboxFrame?.addEventListener('touchend', (event) => {
    const touchEndX = event.changedTouches?.[0]?.clientX || 0;
    const delta = touchEndX - touchStartX;
    if (Math.abs(delta) < 50) return;
    if (delta < 0) moveLightbox(1);
    if (delta > 0) moveLightbox(-1);
  }, { passive: true });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && isMobileViewport()) {
      closeMobileDrawer();
    }
    if (!isLightboxOpen()) return;
    if (event.key === 'Escape') closeLightbox();
    if (event.key === 'ArrowLeft') moveLightbox(-1);
    if (event.key === 'ArrowRight') moveLightbox(1);
  });

  window.addEventListener('resize', () => {
    if (!isMobileViewport()) {
      closeMobileDrawer();
      filtersSidebar?.setAttribute('aria-hidden', 'false');
    } else if (filtersSidebar?.getAttribute('data-mobile-open') !== 'true') {
      filtersSidebar?.setAttribute('aria-hidden', 'true');
    }
  });

  if (!isMobileViewport()) {
    filtersSidebar?.setAttribute('aria-hidden', 'false');
  }
</script>
